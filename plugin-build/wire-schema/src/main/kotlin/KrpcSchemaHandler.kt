package org.kotpot.krpc

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.wire.kotlin.KotlinGenerator
import com.squareup.wire.kotlin.RpcCallStyle
import com.squareup.wire.kotlin.RpcRole
import com.squareup.wire.schema.*
import okio.Path
import java.io.IOException


class KrpcSchemaHandler(
    private val includes: List<String>,
    private val excludes: List<String>,
    private val exclusive: Boolean,
    private val outDirectory: String,
    private val options: Map<String, String>
) : SchemaHandler() {

    private lateinit var kotlinGenerator: KotlinGenerator
    private lateinit var krpcGenerator: KrpcServiceGenerator

    override fun handle(schema: Schema, context: Context) {
        val profile = context.profileLoader!!.loadProfile("kmp", schema)
        krpcGenerator = KrpcServiceGenerator(schema, profile)
        kotlinGenerator = KotlinGenerator(
            schema = schema,
            profile = profile,
            emitAndroid = false,
            javaInterop = false,
            emitDeclaredOptions = true,
            emitAppliedOptions = true,
            rpcCallStyle = RpcCallStyle.SUSPENDING,
            rpcRole = RpcRole.CLIENT,
            boxOneOfsMinSize = 5_000,
            grpcServerCompatible = false,
            nameSuffix = null,
            buildersOnly = false,
            singleMethodServices = false,
        )
        println("KRPC")
        super.handle(schema, context)
    }

    override fun handle(extend: Extend, field: Field, context: Context): Path? {
        val typeSpec = kotlinGenerator.generateOptionType(extend, field) ?: return null
        val name = kotlinGenerator.generatedTypeName(extend.member(field))
        return write(name, typeSpec, field.qualifiedName, field.location, context)

    }

    override fun handle(type: Type, context: Context): Path? {
        if (KotlinGenerator.builtInType(type.type)) return null

        val typeSpec = kotlinGenerator.generateType(type)
        val className = kotlinGenerator.generatedTypeName(type)
        return write(className, typeSpec, type.type, type.location, context)
    }

    override fun handle(service: Service, context: Context): List<Path> {
        val generatedPaths = mutableListOf<Path>()

        fun Pair<ClassName, TypeSpec>.writeToPath() {
            let { (name, type) ->
                write(name, type, service.type, service.location, context)
            }.also { generatedPaths.add(it) }
        }

        krpcGenerator.generateServiceInterface(service).writeToPath()

        println("Generate Krpc $generatedPaths")

        return generatedPaths
    }

    private fun write(
        name: ClassName,
        typeSpec: TypeSpec,
        source: Any,
        location: Location,
        context: Context,
    ): Path {
        val modulePath = context.outDirectory
        val kotlinFile = FileSpec.builder(name.packageName, name.simpleName)
            .addFileComment(CODE_GENERATED_BY_KRPC)
            .addFileComment("\nSource: %L in %L", source, location.withPathOnly())
            .addType(typeSpec)
            .build()
        val filePath = modulePath /
                kotlinFile.packageName.replace(".", "/") /
                "${kotlinFile.name}.kt"

        context.logger.artifactHandled(
            modulePath,
            "${kotlinFile.packageName}.${(kotlinFile.members.first() as TypeSpec).name}",
            "Kotlin",
        )
        try {
            context.fileSystem.createDirectories(filePath.parent!!)
            context.fileSystem.write(filePath) {
                writeUtf8(kotlinFile.toString())
            }
        } catch (e: IOException) {
            throw IOException("Error emitting ${kotlinFile.packageName}.$source to $outDirectory", e)
        }
        return filePath
    }

    companion object {
        private const val CODE_GENERATED_BY_KRPC = "Code generated by Wire protocol buffer compiler, do not edit."
    }
}